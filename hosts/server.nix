{ pkgs, lib, self, ... }:

let
  # TODO: add your public ssh key here to be able to log into the deployed host (as user `me`).
  sshKeys = [
    "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAID7wWcuQm1+P34UvkQiu/fyer+PNyvn+j+uh1MRDyhp5 Generated By Termius"
  ];
  backendPort = "3000";
in
{
  # Garnix server setup
  garnix.server.enable = true;

  # Enable SSH so we can log in
  services.openssh.enable = true;

  # User 'me' with sudo access
  users.users.me = {
    isNormalUser = true;
    description = "me";
    extraGroups = [ "wheel" "systemd-journal" "docker" ];
    openssh.authorizedKeys.keys = sshKeys;
  };

  # Create docker group (so the group exists if any tooling expects it)
  users.groups = {
    docker = {};
  };

  # Allow sudo without password
  security.sudo.wheelNeedsPassword = false;

  # Packages available on the system
  environment.systemPackages = [
    pkgs.htop
    pkgs.tree
    pkgs.docker         # Docker CLI
    pkgs.docker-compose # Docker Compose CLI
  ];

  # Start Docker daemon via the NixOS module (module is `virtualisation.docker`, not `services.docker`)
  virtualisation.docker = {
    enable = true;
    # Socket activation is now always active in newer NixOS modules; do NOT try to disable it.
    # Avoid passing host flags via extraOptions (those become CLI flags) because the generated
    # daemon.json will already include "fd://" for socket activation. Passing hosts both via
    # flags and in the file causes dockerd to fail (directives duplicated).
    # Instead, add the TCP listener via extraConfig so the generated daemon.json contains
    # both fd:// and tcp:// entries and no CLI flags are used.
    extraConfig = {
      hosts = [ "fd://" "tcp://0.0.0.0:2375" ];
    };
  };

  # Ensure the docker unix socket is world-writable so any local user can use Docker
  # (This plus the TCP binding above implements "docker available to all users" as requested.)
  # Do NOT create a regular file at /var/run/docker.sock â€” dockerd creates that socket itself. Creating a regular file there prevents dockerd from binding and will make the service fail.
# Instead, chmod the socket after the daemon starts so local users can use it.
# This uses a systemd unit override for docker.service to run chmod in ExecStartPost.
systemd.services."docker" = {
  serviceConfig = {
    ExecStartPost = "${pkgs.coreutils}/bin/chmod 0666 /var/run/docker.sock";
  };
};

  # Backend service
  systemd.services.backend = {
    description = "example go backend";
    wantedBy = [ "multi-user.target" ];
    wants = [ "network-online.target" ];
    serviceConfig = {
      Environment = "PORT=" + backendPort;
      Type = "simple";
      DynamicUser = true;
      ExecStart = lib.getExe self.packages.${pkgs.system}.backend;
    };
  };

  # Nginx setup
  services.nginx = {
    enable = true;
    recommendedProxySettings = true;
    recommendedOptimisation = true;
    recommendedGzipSettings = true;

    virtualHosts."default" = {
      # Serve frontend bundle
      locations."/".root = "${self.packages.${pkgs.system}.frontend-bundle}";
      # Proxy API requests to backend
      locations."/api".proxyPass = "http://localhost:${backendPort}/";
    };
  };

  # Disable firewall entirely (exposes all ports)
  networking.firewall.enable = false;

  # Required for Garnix
  nixpkgs.hostPlatform = "x86_64-linux";
}
